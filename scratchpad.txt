#include <glm/glm.hpp>
#include <GLFW/glfw3.h>
#include <cstring>
#include "CubeCollider.h"


class Camera {
public:
    glm::mat4 proj;
    int cooldown = 0;
    glm::vec3 position = glm::vec3(0.0f, 3.0f, 0.0f);
    glm::vec3 velocity = glm::vec3(0.0f, 0.0f, 0.0f);
    float yaw = -90.0f; // Starting yaw angle
    float pitch = 0.0f;  // Starting pitch angle
    float roll = 0.0f;   // Starting roll angle
    glm::vec3 positionFeet = glm::vec3(0.0f, 0.0f, 0.0f);
    glm::vec3 colliderPointTopBackLeft;
    glm::vec3 colliderPointTopBackRight;
    glm::vec3 colliderPointTopFrontLeft;
    glm::vec3 colliderPointTopFrontRight;
    glm::vec3 colliderPointBottomBackLeft;
    glm::vec3 colliderPointBottomBackRight;
    glm::vec3 colliderPointBottomFrontLeft;
    glm::vec3 colliderPointBottomFrontRight;  
    float yVelocity = 0.0f;
    bool onGround = false;
    bool isJumping = false;

    CubeCollider collider;



    Camera(glm::vec3 position = glm::vec3(0.0f, 3.0f, 0.0f),
           glm::vec3 target = glm::vec3(0.0f, 0.0f, 0.0f),
           glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
           float movementSpeed = 5.0f,
           float rotationSpeed = 1.0f) :
        position(position), target(target), worldUp(up),
        movementSpeed(movementSpeed), rotationSpeed(rotationSpeed) {

    }

    // Accessors
    glm::mat4 getViewMatrix() const {
        return glm::lookAt(position, target, worldUp);
    }

    bool getOnGround() const {
        return onGround;
    }

    // Rotation functions (assuming mouse movement for rotation)
    void rotate(float xoffset, float yoffset) {
        xoffset *= rotationSpeed;
        yoffset *= rotationSpeed;

        glm::vec3 front = glm::normalize(target - position);
        glm::vec3 right = glm::normalize(glm::cross(front, worldUp));
        glm::vec3 up = glm::normalize(glm::cross(right, front));

        yaw += xoffset;
        pitch += yoffset;

        // Clamp pitch to avoid looking too far up or down
        pitch = glm::clamp(pitch, -89.0f, 89.0f);

        target = position + glm::vec3(
            cos(glm::radians(yaw)) * cos(glm::radians(pitch)),
            sin(glm::radians(pitch)),
            sin(glm::radians(yaw)) * cos(glm::radians(pitch))
        );
    }

    glm::vec3 getRay()
    {
        glm::vec3 front = glm::normalize(target - position);
        return front;
    }

    void Update(GLFWwindow* window, float dt, bool& isMouseActive)
    {

        glfwPollEvents();
        int count;
        int properControllerIndex = -1; 
        const unsigned char* axes;
        const unsigned char* buttons;
        const float* thumbstickAxes;
        int amountOfJoysticksConnected = 0;
        float cameraSpeed = .1f;
        float rotationSpeed = .1f;

        positionFeet = glm::vec3(position.x, position.y-3, position.z);
        
        if (cooldown > 0)
            cooldown--;

        //if tab is pressed, toggle isMouseActive
        if (glfwGetKey(window, GLFW_KEY_TAB) == GLFW_PRESS && cooldown == 0)
        {
            isMouseActive = !isMouseActive;
            cooldown = 20;
        }
    
        if (isMouseActive)
        {
            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
            return;
        }
        else
        {
            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            double xpos, ypos;
            glfwGetCursorPos(window, &xpos, &ypos);
            int width, height;
            glfwGetWindowSize(window, &width, &height);
            glfwSetCursorPos(window, width / 2, height / 2);
            float xoffset = xpos - width / 2;
            float yoffset = height / 2 - ypos;
            rotate(xoffset * rotationSpeed, yoffset * rotationSpeed);
        }

        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
            glm::vec3 movement = cameraSpeed * glm::normalize(target - position);
            movement.y = 0;
            position += movement;
        }

        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
            glm::vec3 movement = cameraSpeed * glm::normalize(target - position);
            movement.y = 0;
            position -= movement;
        }

        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        {    
            glm::vec3 movement = cameraSpeed * glm::normalize(glm::cross(target - position, worldUp));
            movement.y = 0;
            position -= movement;
        }

        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        {
            glm::vec3 movement = cameraSpeed * glm::normalize(glm::cross(target - position, worldUp));
            movement.y = 0;
            position += movement;
        }

        if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
        {
            if (onGround)
            {
                yVelocity = .1f;
                onGround = false;
                isJumping = true;
            }
        }

        if (!onGround)
        {
            position.y += yVelocity;
        }

        if (!onGround)
        {
            yVelocity -= 0.005f;

        }
    }

    glm::vec3 getViewDirection() const
    {
        // Calculate the view direction vector
        return glm::normalize(target - position);
    }


private:
    
    glm::vec3 target;
    glm::vec3 worldUp;
    float movementSpeed;
    float rotationSpeed;

    glm::mat4 view;

    glm::mat4 model;
    glm::mat4 mvp;

    
};
